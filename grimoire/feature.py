"""
Classes for sequence features
"""

import operator

import grimoire.toolbox as toolbox

class FeatureError(Exception):
	pass

class Feature:
	"""Class representing a sequence feature, which may have children."""

	def __init__(self, dna, beg, end, strand, type,
			phase='.', score='.', source='.', id=None, pid=None):
		"""
		Parameters
		----------
		+ dna     `DNA`   object of type `sequence.DNA`
		+ beg     `int`   1-based coordinate
		+ end     `int`   1-based coordinate
		+ strand  `str`   '+' or '-', or '.' for undefined
		+ type    `str`   token, hopefully SO-compliant
		+ phase=  `.`     may be {0, 1, 2} or '.' for undefined
		+ score=  `float` often unspecified as `.`
		+ source= `.`     creator of feature (e.g. WormBase)
		+ id=     `str`   unique identifier, optional
		+ pid=    `str`   a parent id or list of parent ids
		
		Attributes
		----------
		+ issues	`list` warnings and errors generated by `Feature.validate()`
		+ children	`list` sub-features
		+ validated	`bool` check if this has been validated
		"""

		self.dna = dna
		self.beg = beg
		self.end = end
		self.length = end - beg + 1
		self.strand = strand
		self.type = type
		self.phase = phase
		self.id = id
		self.pid = []
		if pid:
			if   isinstance(pid, list): self.pid = pid
			elif isinstance(pid, str):  self.pid.append(pid)
			else: raise FeatureError('pid must be string or list of strings')
		self.score = score
		self.source = source
		self.issues = {}
		self.children = []
		self.validated = False

		if self.dna == None:
			raise GenomeError('attempt to create feature unbound to DNA')
		self._validate()

	def _validate(self):
		if self.beg < 1:                 raise FeatureError('beg<1')
		if self.beg > self.end:          raise FeatureError('beg>end')
		if self.end > len(self.dna.seq): raise FeatureError('end>len')
		if self.children:
			for child in self.children:
				child.validate()
				if child.beg < self.beg:
					self.issues['child.beg<parent.beg'] = True
				if child.end > self.end:
					self.issues['child.end>parent.end'] = True
				if child.strand != self.strand:
					self.issues['mixed_strands'] = True
				if child.issues:
					self.issues['child_issues'] = True

	def _revcomp(self):
		if  self.strand  == '+': self.strand = '-'
		elif self.strand == '-': self.strand = '+'
		new_beg = len(self.dna.seq) - self.end + 1
		new_end = len(self.dna.seq) - self.beg + 1
		self.beg = new_beg
		self.end = new_end
		for child in self.children:
			child._revcomp()

	def validate(self):
		"""Check `Feature` instance for common errors, populating issues."""

		if self.validated: return
		self._validate()
		self.validated = True

	def add_parent(self, pid):
		"""
		Adds a parent identifier to a `Feature` object.
		
		Parameters
		----------
		+ pid `str` parent identifier token (e.g. gene name)
		"""
		if pid not in self.pid:
			self.pid.append(pid)

	def add_child(self, child):
		"""
		Adds a child to `Feature` object, unsetting validated flag.

		Parameters
		----------
		+ child `Feature` feature object
		"""

		self.validated = False
		if not self.id:
			raise GenomeError('parent feature requires ID')
		elif not isinstance(child, Feature):
			raise GenomeError('child feature is not a valid Feature object')
		else:
			self.children.append(child)

	def seq_str(self):
		"""Returns the sequence of a `Feature` as a `str` in + strand."""

		seq = self.dna.seq[self.beg-1:self.end]
		if self.strand == '-': seq = toolbox.revcomp_str(seq)
		return seq

	def gff(self):
		"""Returns a string representation of a feature in GFF3 format."""
		if not self.validated: self.validate()

		attr = ''
		if self.id and self.pid:
			attr = 'ID=' + self.id + ';Parent=' + ','.join(self.pid)
		elif self.id:
			attr = 'ID=' + self.id
		elif self.pid:
			attr = 'Parent=' + ','.join(self.pid)

		string = '\t'.join([self.dna.name, self.source, self.type,
			str(self.beg), str(self.end), str(self.score),
			self.strand, self.phase, attr])
		if self.children:
			string += '\n'
			stuff = []
			for child in self.children:
				stuff.append(child.gff())
			string += '\n'.join(stuff) + '\n'
		return string

	def overlap(self, f2):
		"""
		Determines if two features overlap.

		Parameters
		----------
		+ f2 `Feature` the other feature (self implicitly f1)
		"""

		if self.dna.name == f2.dna.name:
			if self.beg >= f2.beg and self.beg <= f2.end: return True
			if self.end >= f2.beg and self.end <= f2.end: return True
			if self.beg <= f2.beg and self.end >= f2.end: return True
		return False
	
	def __str__(self):
		return self.gff()

class Transcript(Feature):
	"""Base class for transcripts (children of `Gene`s)."""

	def _check_overlaps(self, f, type):
		for i in range(1, len(f)):
			if f[i-1].end >= f[i].beg:
				self.issues['overlap_' + type] = True

	def _check_lengths(self, features, type):
		for f in features:
			if f.length < self.limit[type]['min']:
				self.issues['short_' + type] = True
			if f.length > self.limit[type]['max']:
				self.issues['long_' + type] = True

	def tx_str(self):
		"""Returns the transcript as a string with introns removed."""
		
		if not self.validated: self.validate()
		seq = []
		for exon in self.exons: seq.append(exon.seq_str())
		if self.strand == '-': seq.reverse()
		return ''.join(seq)

class mRNA(Transcript):
	"""Class for protein-coding mRNAs. Not for ncRNAs.
	
	Extends the base `Feature` class. mRNAs are created by first instantiating
	a parent `mRNA`. Then `add_child()` of type 'exon' _and_ 'CDS'.
	Introns and untranslated regions are inferred from the coordinates
	of the exon and CDS features. **The mRNA must have an 'id' so that its
	children can reference it.** You don't need to spcifiy 'pid' in the
	children, as this will be assigned automatically.
	
	Extended attributes (`mRNA`-specific)
	----------
	+ exons		`list`	exons
	+ inrons	`list`	introns
	+ cdss		`list`	CDSs
	+ utr5s		`list`	5' UTRs
	+ utr3s		`list`	3' UTRs
	"""

	clade = 'std' #standard
	limit = {
		'exon':   {'min':20, 'max':10000},
		'cds':    {'min':1,  'max':10000},
		'utr5':   {'min':0,  'max':1000},
		'utr3':   {'min':0,  'max':1000},
		'intron': {'min':30, 'max':10000},
	}
	dons = {'GT':True}
	accs = {'AG':True}
	starts = {'ATG':True}
	stops = {'TAA':True, 'TGA':True, 'TAG':True}

	def set_rules(self, clade='std'):
		"""Set rules for mRNA by clade.
		
		+ dons		`dict` allowable donor sites (e.g. GT)
		+ accs		`dict` allowable acceptor sites (e.g. AG)
		+ starts	`dict` allowable start sites (e.g. ATG)
		+ stops		`dict` allowable stop sites (e.g. TAA, TGA, TAG)
		+ limit		`dict` of `dict`s containing length limits for sub-features

		Parameters
		----------
		+ clade `str` name of clade ('std' or 'mammal')
		"""

		if clade == 'std':
			pass # the defaults are considered standard
		elif clade == 'mammal':
			self.limit['intron'][min] = 50
			self.limit['intron'][max] = 100000
		else:
			raise NotImplemented('clade not yet supported: ' + clade)
		self.clade = clade

	def validate(self):
		"""Checks mRNA for common errors, populating issues."""

		if self.validated: return
		if not self.id: raise FeatureError('mRNAs must have ids')
		self._validate()

		# mRNA properties (extended constructor)
		self.is_coding = True
		self.exons = []
		self.introns = []
		self.cdss = []
		self.utr5s = []
		self.utr3s = []

		for f in self.children:
			if   f.type == 'exon': self.exons.append(f)
			elif f.type == 'CDS': self.cdss.append(f)
			else: raise FeatureError('mRNA takes exon and CDS only')
			if f.pid == None:
				f.pid = self.id

		if len(self.cdss) == 0:
			self.issues['no_CDS'] = True

		self.exons.sort(key = operator.attrgetter('beg'))
		self.cdss.sort(key = operator.attrgetter('beg'))

		# create introns from exons
		for i in range(len(self.exons)-1):
			beg = self.exons[i].end +1
			end = self.exons[i+1].beg -1
			self.introns.append(
				Feature(self.dna, beg, end, self.strand, 'intron'))

		# create 5' and 3' UTRs from exons and CDSs
		if len(self.cdss) > 0:
			cds_beg = self.cdss[0].beg
			cds_end = self.cdss[-1].end
			for exon in self.exons:
				if exon.beg < cds_beg:
					ub = exon.beg
					ue = None
					if exon.end < cds_beg: ue = exon.end
					else:                  ue = cds_beg -1
					if exon.strand == '+':
						self.utr5s.append(Feature(self.dna, ub, ue, self.strand,
							'five_prime_UTR'))
					else:
						self.utr3s.append(Feature(self.dna, ub, ue, self.strand,
							'three_prime_UTR'))
				if exon.end > cds_end:
					ub = None
					ue = exon.end
					if exon.beg < cds_end: ub = cds_end + 1
					else:                  ub = exon.beg
					if exon.strand == '+':
						self.utr3s.append(Feature(self.dna, ub, ue, self.strand,
							'three_prime_UTR'))
					else:
						self.utr5s.append(Feature(self.dna, ub, ue, self.strand,
							'five_prime_UTR'))

		# check for overlapping features
		self._check_overlaps(self.exons, 'exon')
		self._check_overlaps(self.cdss, 'cds')
		self._check_overlaps(self.utr5s, 'utr5')
		self._check_overlaps(self.utr3s, 'utr3')
		self._check_overlaps(self.introns, 'intron')

		# check for unusual lengths
		self._check_lengths(self.exons, 'exon')
		self._check_lengths(self.cdss, 'cds')
		self._check_lengths(self.utr5s, 'utr5')
		self._check_lengths(self.utr3s, 'utr3')
		self._check_lengths(self.introns, 'intron')

		# canonical splicing
		for intron in self.introns:
			s = intron.seq_str()
			don = s[0:2]
			acc = s[-2:len(s)]
			if don not in self.dons: self.issues['donor'] = True
			if acc not in self.accs: self.issues['acceptor'] = True

		# translation checks
		self.validated = True # must be set now to use str methods
		cds = self.cds_str()
		pro = toolbox.translate_str(cds)
		start = cds[0:3]
		stop = cds[-3:len(cds)]
		if start not in self.starts: self.issues['start'] = True
		if stop not in self.stops: self.issues['stop'] = True
		for i in range(len(pro) - 1):
			if pro[i:i+1] == '*': self.issues['ptc'] = True

	def cds_str(self):
		"""Returns sequence of coding exons as a string."""
		if not self.validated: self.validate()
		seq = []
		for exon in self.cdss: seq.append(exon.seq_str())
		if self.strand == '-': seq.reverse()
		return ''.join(seq)

	def protein_str(self):
		"""Translates coding sequence and returns protein sequence as a string."""
		if not self.validated: self.validate()
		return toolbox.translate_str(self.cds_str())

class ncRNA(Transcript):
	"""Class for non-coding RNAs.
	
	Extends the base `Feature` class for ncRNAs. Don't use this class
	for protein-coding mRNAs because it does not make sanity checks on
	protein-coding sequence.
	
	`ncRNAs`s are created by first instantiating this class and then using
	the `add_child()` method (from the parent `Feature` class) to add features
	of type 'exon'. **All 'ncRNA`s must have an 'id'.** Children will automatically
	reference this in their 'pid'.
	
	Extended attributes (`ncRNA`-specific)
	----------
	+ exons - list of exons
	+ inrons - list of introns
	"""

	clade = 'std' #standard
	limit = {
		'exon':   {'min':20, 'max':10000},
		'intron': {'min':30, 'max':10000},
	}
	dons = {'GT':True}
	accs = {'AG':True}

	def set_rules(self, clade='std'):
		"""Set rules for ncRNA by clade.
		
		+ dons - dictionary of donor sites (e.g. GT)
		+ accs - dictionary of acceptor sites (e.g. AG)
		+ limit - 2d dictionary of length limits

		Parameters
		----------
		+ clade `str` name of clade ('std' or 'mammal')
		"""

		if clade == 'std':
			pass # the defaults are considered standard
		elif clade == 'mammal':
			self.limit['intron'][min] = 50
			self.limit['intron'][max] = 100000
		else:
			raise NotImplemented('clade not yet supported: ' + clade)
		self.clade = clade

	def validate(self):
		"""Checks ncRNA for common errors, populating issues."""

		if self.validated: return
		if not self.id: raise FeatureError('ncRNAs must have ids')
		self._validate()

		# mRNA properties (extended constructor)
		self.is_coding = False
		self.exons = []
		self.introns = []

		for f in self.children:
			if   f.type == 'exon': self.exons.append(f)
			else: raise GenomeError('unknown type: ' + f.type)

		self.exons.sort(key = operator.attrgetter('beg'))

		# create introns from exons
		for i in range(len(self.exons)-1):
			beg = self.exons[i].end +1
			end = self.exons[i+1].beg -1
			self.introns.append(
				Feature(self.dna, beg, end, self.strand, 'intron'))

		# check for overlapping features
		self._check_overlaps(self.exons, 'exon')
		self._check_overlaps(self.introns, 'intron')

		# check for unusual lengths
		self._check_lengths(self.exons, 'exon')
		self._check_lengths(self.introns, 'intron')

		# canonical splicing
		for intron in self.introns:
			s = intron.seq_str()
			don = s[0:2]
			acc = s[-2:len(s)]
			if don not in self.dons: self.issues['donor'] = True
			if acc not in self.accs: self.issues['acceptor'] = True

class Gene(Feature):
	"""
	Class for genes, which have `Transcript` children.
	
	Extends the base `Feature` class. Genes are created by first instantiating
	a parent `Gene`. Then `add_child()` of some `Transcript` class such as
	`mRNA` or `ncRNA`. **The gene must have an 'id' so that its children can
	reference it.**
	"""

	def transcripts(self):
		"""Returns a list of transcripts. Just an alias for children."""

		if not self.validated:
			self.validate()
		return self.children

	def validate(self):
		"""Runs validators for self anc children."""
	
		if not self.id: raise FeatureError('genes must have ids')
		if self.pid: raise FeatureError('genes have no pids')
		self._validate()
		for f in self.children:
			if f.pid == None:
				f.pid = self.id
		self.validated = True

class FeatureTable:
	"""A collection of features from the same parent DNA."""
	
	def __init__(self, dna=None, features=None):
		"""
		Parameters
		----------
		+ dna=      `DNA` object
		+ features= `list` of `Feature` objects (optional)
		"""
		self.dna = dna
		self._sorted = False
		if features:
			self.features = features
		else:
			self.features = []
		if self.dna and self.features:
			for f in self.features:
				if f.dna is not self.dna:
					raise FeatureError('reference mismatch within FeatureTable')
		elif self.features:
			for f in self.features:
				if f.dna is not self.features[0].dna:
					raise FeatureError('reference mismatch within FeatureTable')
			

	def add_feature(self, feature):
		"""
		Parameters
		----------
		+ feature `Feature` object
		"""
		
		if self.features:
			if self.features[0].dna is feature.dna:
				self.features.append(feature)
			else:
				raise FeatureError('reference mismatch within FeatureTable')
		else:
			self.features.append(feature)
		self._sorted = False

	def _sort(self):
		if not self._sorted:
			self.features.sort(key=operator.attrgetter('beg', 'end'))
		self._sorted = True

	def _revcomp(self):
		"""Reverse complements features in table."""
		for f in self.features:
			f._revcomp()
		self._sorted = False

	def gff(self):
		"""Returns the feature table formatted as GFF."""
		
		lines = []
		for f in self.features:
			lines.append(f.gff())
		return '\n'.join(lines)

	def build_genes(self):
		"""
		Returns a list of `Gene` objects. Currently, only `mRNA` objects
		are constructed from features of type 'exon' and 'CDS' but in
		the future, there ought to be `ncRNA` objects as well. See the
		`Gene`, `Transcript`, `mRNA`, and `ncRNA` objects.

	
		In order for the exon/CDS features to be grouped into transcripts
		and then into genes, the features must use the `Feature`
		id and pid attributes correctly.
		"""
	
		genes = {}
		mRNAs = {}
		parts = []
		for f in self.features:
			if f.type == 'gene':
				if f.id == None: raise FeatureError('genes need ids')
				genes[f.id] = Gene(f.dna, f.beg, f.end, f.strand, f.type,
					id=f.id)
			elif f.type == 'mRNA':
				if f.id == None: raise FeatureError('mRNAs need ids')
				if f.pid == None: raise FeatureError('mRNAs need pids')
				mRNAs[f.id] = mRNA(f.dna, f.beg, f.end, f.strand, f.type,
					id=f.id, pid=f.pid)
			elif f.type == 'exon' or f.type == 'CDS':
				if f.pid == None: raise FeatureError('need parent')
				parts.append(f)
	
		# add parts to mRNAs
		for f in parts:
			for pid in f.pid:
				if pid in mRNAs:
					mRNAs[pid].add_child(f)

		# add mRNAs to genes
		for txid in mRNAs:
			f = mRNAs[txid]
			if len(f.pid) != 1: raise FeatureError('mRNA pids != 1')
			pid = f.pid[0]
			if pid in genes:
				genes[pid].add_child(f)
	
		# perform sanity checks on all genes
		for gid in genes:
			genes[gid].validate()
	
		return list(genes.values())

	def fetch(self, beg, end):
		"""Returns a list of features between beg and end."""
		
		if beg < 1: raise FeatureError('beg out of range')
		if end > len(self.dna.seq): raise FeatureError('end out of range')
		if len(self.features) == 0: return []
		
		self._sort()
		
		# do linear search for short lists
		if len(self.features) < 4:
			found = []
			for f in self.features:
				if   f.beg >= beg and f.beg <= end: found.append(f)
				elif f.end >= beg and f.end <= end: found.append(f)
				elif f.beg <  beg and f.end >  end: found.append(f)
			return found
		
		# binary search the non-unique beg feature
		lo, hi = 0, len(self.features) -1
		prev = None
		while True:
			m = int((hi + lo) / 2)
			if m == prev: break
			prev = m
			if   self.features[m].beg < beg: lo = m
			elif self.features[m].beg > beg: hi = m

		# check in reverse that it's the true start of the list
		n = lo
		while self.features[n].beg < beg:
			if n == 0: break
			n -= 1
		
		# get all features in bounds
		found = []
		while n < len(self.features):
			fb, fe = self.features[n].beg, self.features[n].end
			if fe < beg:
				n += 1
				continue
			elif fb > end:
				break
			else:
				found.append(self.features[n])
				n += 1
		
		return found
		

