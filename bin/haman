#!/usr/bin/env python3

import argparse
import sys
import operator
import os
import copy
import json

from grimoire.sequence import DNA
from grimoire.feature import Feature, mRNA, Gene, FeatureTable
from grimoire.genome import Reader
import grimoire.io as gio

## Command line stuff ##

extended_help = """

haman is used for converting chromosome-based genomic data into smaller pieces.
This is useful in a training environment when you want to create cross
validation training and testing sets or when you want a minimal set for
tutorials and functional tests.

Segmenting by percent keeps the first x% of the genome and saves as <out>.fa
and <out.gff>.

Segmenting by gene focuses on plus strand protein-coding genes. Output is fasta
and gff in the <out> directory.

Segmenting by region splits the chromosome into regions of non-overlapping genes.

"""

parser = argparse.ArgumentParser(
	description='Segments chromosome sequences and features.',
	formatter_class=argparse.RawDescriptionHelpFormatter,
	epilog=extended_help)
parser.add_argument('fasta', type=str, metavar='<fasta>',
	help='path to input fasta file')
parser.add_argument('gff', type=str, metavar='<gff>',
	help='path to input GFF3 (or similar) file')
parser.add_argument('method', type=str, metavar='<method>',
	help='gene|protein|region|percent')
parser.add_argument('out', type=str, metavar='<out>',
	help='output name (file or dir)')
parser.add_argument('--pct', required=False, type=int, default=1.0,
	metavar='<int>', help='for use with percent segmenting [%(default).3f]')
parser.add_argument('--source', required=False, type=str,
	metavar='<str>', help='rule-based parsing based on gff source')
parser.add_argument('--padding', required=False, type=int, default=100,
	metavar='<int>', help='start of first feature [%(default)d]')
arg = parser.parse_args()

class HamanError(Exception):
	pass

def remap_export(root, name, chrom, regions, idx, plus=False):

	# remap sequence and features smaller and export
	for region in regions:
		idx += 1

		# dna
		seq = chrom.seq[region.beg:region.end+1] # +1 or not?
		dna = DNA(name=str(idx), seq=seq,
			desc=f'chrom:{chrom.name} beg:{region.beg} end:{region.end}')

		# feature table
		stuff = chrom.ftable.fetch(region.beg, region.end)
		keep = []
		for f in stuff:
			if f.beg <= region.beg or f.end >= region.end: continue
			keep.append(f)

		for f in keep:
			nbeg = f.beg - region.beg
			nend = f.end - region.beg
			dna.ftable.add_feature(Feature(dna, nbeg, nend,
				f.strand, f.type, phase=f.phase,
				score=f.score, source=f.source, id=f.id, pid=f.pid))

		if plus: dna.revcomp()

		# output
		ffp = open(f'{root}/{idx}.fa', 'w+')
		ffp.write(dna.fasta())
		ffp.close()
		gfp = open(f'{root}/{idx}.gff', 'w+')
		for f in dna.ftable.features:
			gfp.write(f.gff())
			gfp.write('\n')

	return idx

def segment_by_gene():

	if os.path.exists(arg.out):
		raise HamanError('output dir exists, will not overwrite')
	os.mkdir(arg.out)

	genome = Reader(gff=arg.gff, fasta=arg.fasta)
	idx = 0
	for chrom in genome:
		regions = []
		for gene in chrom.ftable.build_genes():
			if gene.issues: continue
			if len(gene.transcripts()) == 0: continue # RNA genes
			beg = gene.beg - arg.padding
			end = gene.end - arg.padding
			if gene.beg < 1 or gene.end >= len(chrom.seq): continue
			region = Feature(chrom, beg, end, '.', 'region', source='haman')
			regions.append(region)
		idx = remap_export(arg.out, 'gene', chrom, regions, idx, plus=True)

def segment_by_region():

	if os.path.exists(arg.out):
		raise HamanError('output dir exists, will not overwrite')
	os.mkdir(arg.out)

	genome = Reader(gff=arg.gff, fasta=arg.fasta, source=arg.source)
	idx = 0
	for chrom in genome:

		# create regions of overlapping genes
		chrom.ftable._sort()
		genes = []
		for f in chrom.ftable.features:
			if f.type == 'gene': genes.append(f)
		regions = []
		skip = 0
		for i in range(len(genes)):
			if skip > i: continue
			beg = genes[i].beg - arg.padding
			end = genes[i].end + arg.padding
			if beg < 1: beg = 1
			if end > len(chrom.seq): end = len(chrom.seq)
			region = Feature(chrom, beg, end, '.', 'region', source='haman')
			for j in range(i + 1, len(genes)):
				if genes[j].overlap(region):
					if genes[j].end > region.end:
						region.end = genes[j].end
				else:
					skip = j
					break
			regions.append(region)

		idx = remap_export(arg.out, 'region', chrom, regions, idx)

def segment_by_percent():
	FRACTION = arg.pct / 100

	chrom = {}
	with open(f'{arg.out}.fa', 'w') as fp:
		for entry in gio.FASTA_stream(filename=arg.fasta):
			l = int(len(entry.seq) * FRACTION)
			chrom[entry.id] = entry.seq[0:l]
			fp.write(f'>{entry.id} 1..{l+1}\n')
			for i in range(0, len(chrom[entry.id]), 50):
				fp.write(f'{chrom[entry.id][i:i+50]}\n')

	with open(f'{arg.out}.gff', 'w') as fp:
		for gff in gio.GFF_stream(filename=arg.gff):
			limit = len(chrom[gff.chrom])
			if gff.beg < limit and gff.end < limit:
				fp.write(f'{gff}')

## CLI ##

if   arg.method == 'gene':    segment_by_gene()
elif arg.method == 'region':  segment_by_region()
elif arg.method == 'percent': segment_by_percent()
else: raise HamanError('unknown method: ' + arg.method)
