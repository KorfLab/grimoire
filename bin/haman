#!/usr/bin/env python3

import argparse
import sys
import operator
import os
import copy

from grimoire.sequence import DNA
from grimoire.feature import Feature, mRNA, Gene, FeatureTable
from grimoire.genome import Reader

## Command line stuff ##

extended_help = """
%(prog)s is used for converting chromosome-based genomic data into
smaller pieces. This is useful in a training environment when you want
to create cross-validation training and testing sets.

Segmenting by gene goes through protein-coding gene build and saves as
fasta + gff3.

Segmenting by region pulls all gff of gene-ic regions (overlaps merged) and
saves as a directory of regions.

Source: wb.270 wormbase filtering
"""

parser = argparse.ArgumentParser(
	description='Segments chromosome sequences and features.',
	formatter_class=argparse.RawDescriptionHelpFormatter,
	epilog=extended_help)
parser.add_argument('--fasta', required=True, type=str,
	metavar='<path>', help='path to input fasta file')
parser.add_argument('--gff', required=True, type=str,
	metavar='<path>', help='path to input GFF3 (or similar) file')
parser.add_argument('--out', required=True, type=str,
	metavar='<str>', help='output name (file or dir)')
parser.add_argument('--segment', required=False, type=str,
	metavar='<str>', help='gene|region')
parser.add_argument('--source', required=False, type=str,
	metavar='<str>', help='rule-based parsing based on gff source')
parser.add_argument('--split', required=False, type=int, default=1,
	metavar='<int>', help='split into <int> parts [%(default)d]')
parser.add_argument('--padding', required=False, type=int, default=100,
	metavar='<int>', help='length of flanking sequence [%(default)d]')
arg = parser.parse_args()

class HamanError(Exception):
	pass

def chromify(g, beg, end):
	dna = DNA(seq=g.dna.seq[beg:end], name=g.id + '-remapped')
	dna.ftable.add_feature(Feature(dna, g.beg -beg, g.end -beg, g.strand,
		'gene', id=g.id))
	for t in g.transcripts():
		dna.ftable.add_feature(Feature(dna, t.beg -beg, t.end -beg,
			t.strand, t.type, id=t.id, pid=t.pid))
		for f in t.children:
			dna.ftable.add_feature(Feature(dna, f.beg -beg, f.end -beg,
				f.strand, f.type, pid=f.pid))
	if g.strand == '-':
		dna.revcomp()
	return dna

def segment_by_genes():

	fp = []
	if arg.split:
		for i in range(arg.split):
			fp.append({
				'gf':open(arg.out + '-' + str(i) + '.gff3', 'w+'),
				'ff':open(arg.out + '-' + str(i) + '.fa', 'w+'),
			})

	count = 0
	genome = Reader(gff=arg.gff, fasta=arg.fasta)
	for chrom in genome:
		for gene in chrom.ftable.build_genes():
			if gene.issues: continue
			if len(gene.transcripts()) == 0: continue # RNA genes?
			rbeg = gene.beg - arg.padding -1
			rend = gene.end + arg.padding +1
			if rbeg < 1 or rend > len(chrom.seq): continue
			dna = chromify(gene, rbeg, rend)
			set = count % arg.split
			count += 1
			fp[set]['gf'].write(dna.ftable.gff() + '\n')
			fp[set]['ff'].write(dna.fasta())

def segment_by_regions():

	if os.path.exists(arg.out):
		raise HamanError('output dir exists, will not overwrite')
	os.mkdir(arg.out)
	
	genome = Reader(gff=arg.gff, fasta=arg.fasta, source=arg.source)
	idx = 0
	for chrom in genome:
	
		# create regions of overlapping genes
		chrom.ftable._sort()
		genes = []
		for f in chrom.ftable.features:
			if f.type == 'gene': genes.append(f)
		regions = []
		skip = 0
		for i in range(len(genes)):
			if skip > i: continue
			beg = genes[i].beg - arg.padding
			end = genes[i].end + arg.padding
			if beg < 1: beg = 1
			if end > len(chrom.seq): end = len(chrom.seq)
			region = Feature(chrom, beg, end, '.', 'region', source='haman')
			for j in range(i + 1, len(genes)):
				if genes[j].overlap(region):
					if genes[j].end > region.end:
						region.end = genes[j].end
				else:
					skip = j
					break
			regions.append(region)
		
		# remap sequence and features smaller and export
		for region in regions:
			idx += 1
			dir = arg.out + '/' + str(idx)
			os.mkdir(dir)
			
			# fasta
			seq = chrom.seq[region.beg:region.end+1] # +1 or not?
			dna = DNA(name=str(idx), seq=seq,
				desc='chrom:{} beg:{} end:{}'.format(chrom.name,
				region.beg, region.end))
			ffp = open(dir + '/' + str(idx) + '.fa', 'w+')
			ffp.write(dna.fasta())
			ffp.close()
						
			# gff
			stuff = chrom.ftable.fetch(region.beg, region.end)
			keep = []
			for f in stuff:
				if f.beg < region.beg or f.end > region.end: continue
				keep.append(f)
			remap = []
			for f in keep:
				remap.append(Feature(dna, f.beg - region.beg + 1,
					f.end - region.beg + 1, f.strand, f.type, phase=f.phase,
					score=f.score, source=f.source, id=f.id, pid=f.pid))
			gfp = open(dir + '/' + str(idx) + '.gff', 'w+')
			for f in remap:
				gfp.write(f.gff())
				gfp.write('\n')

if __name__ == '__main__':
	if arg.segment == 'gene':
		segment_by_genes()
	elif arg.segment == 'region':
		segment_by_regions()
	else:
		raise HamanError('unknown segmentation type: ' + arg.segment)

# There might be a better way to do this by simply taking all the gff
# in any region. Why build genes at all?





