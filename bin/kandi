#!/usr/bin/env python3

import argparse
import sys
import os
import curses
import curses.textpad

from grimoire.sequence import DNA
from grimoire.feature_table import FeatureTable
from grimoire.io import FASTA_stream, GFF_file
from grimoire.genome import gff_to_feature
from grimoire.feature import Feature

## Command line stuff ##

extended_help = """
%(prog)s is a very simple terminal-based genome browser designed for testing
and debugging seqeunce analysis algorithms. It loads all of the
sequences and features into memory and doesn't do any coordinate
indexing. It is therefore not suitable for complete genomes.
"""

parser = argparse.ArgumentParser(
	description='Terminal-based genome browser.',
	formatter_class=argparse.RawDescriptionHelpFormatter,
	epilog=extended_help)
parser.add_argument('fasta', nargs=1, help='a fasta file')
parser.add_argument('gff', nargs='+', help='some gff (or other) files')
arg = parser.parse_args()

#############
## Globals ##
#############

class KandiError(Exception): pass

D = []  # dnas: indexed in order of FASTA file
G = []  # genes: indexed by fasta# then gene#
F = []  # files: annotation file name
B = { # browser state
	'idx':None, # current dna object number
	'dna':None, # current dna object
	'beg':None, # begin coordinate of viewer window
	'end':None, # end coordinate of viewer window
	'mat':None, # matrix of screen contents
	'tab':40,   # tab stop for focus data
	'p':None,   # approximate position of the cursor in sequence coordinates
	'x':None,   # cursor x position
	'y':None,   # cursor y position
	'z':None,   # size of cursor (in letters)
	'h':None,   # last height of terminal
	'w':None,   # last width of terminal
}

KANDI_HELP = """
 KANDI help screen

 General
 + The top line displays current location and context information
 + The bottom line displays menu items

 Selector
 + Use the up/down arrow keys to choose a sequence
 + Use the return key to select a sequence for browsing

 Browser
 + Use the arrow keys to move the cusor around
 + When the cursor is on a feature, there will be descriptive text at the top
 + Use the +/- keys to zoom
 + Add the shift key to make bigger steps (both left/right and zoom)
 + Use the return key to zoom in on the feature under cursor
"""

def help_screen(stdscr):
	curses.curs_set(0)

	while True:
		stdscr.clear()
		H, W = stdscr.getmaxyx()
		
		# content
		stdscr.addstr(2, 1, KANDI_HELP)
	
		# location & menu
		loc = '{}:{}-{}'.format(B['dna'].name, B['beg'], B['end'])
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(H-1, 0, '(s)elector (v)iewer (q)uit',
			curses.color_pair(1))

		# action
		k = stdscr.getch()
		if   k == ord('s'): select_screen(stdscr)
		elif k == ord('v'): view_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		else: curses.flash()
		
def select_screen(stdscr):
	curses.curs_set(2)
	top = 4
	bot = top + len(D) -1
	B['x'] = 3
	B['y'] = top
	stdscr.move(B['y'], B['x'])
	k = None

	while True:
		stdscr.clear()
		H, W = stdscr.getmaxyx()
		
		# content
		stdscr.addstr(2, 1, 'KANDI chromosome selector.')	
		for i in range(len(D)):
			stdscr.addstr(4 + i, 4, D[i].name)
	
		# location & menu
		loc = '{}:{}-{}'.format(B['dna'].name, B['beg'], B['end'])
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(H-1, 0, '(b)rowser (h)elp (q)uit', curses.color_pair(1))

		# action
		if   k == ord('h'): help_screen(stdscr)
		elif k == ord('v'): view_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		elif k == 258: B['y'] = B['y'] + 1
		elif k == 259: B['y'] = B['y'] - 1
		elif k == 10:
			init_chrom(B['y'] - top)
			view_screen(stdscr)
		
		if B['y'] < top: B['y'] = top
		if B['y'] > bot: B['y'] = bot
		stdscr.move(B['y'], B['x'])
		k = stdscr.getch()

def plot_text(stdscr, text, color):
	mat = B['mat']
	for y in range(len(mat)):
		clear = True
		for x in range(len(mat[y])):
			if mat[y][x]:
				clear = False
				break
		if clear:
			stdscr.addstr(y+1, 0, text, curses.color_pair(color))
			for x in range(len(mat[y])):
				mat[y][x] = text
			return

def plot_divider(stdscr):
	mat = B['mat']
	for y in range(len(mat)):
		clear = True
		for x in range(len(mat[y])):
			if mat[y][x]:
				clear = False
				break
		if clear:
			stdscr.addstr(y+1, 0, '-' * B['w'], curses.color_pair(0))
			for x in range(len(mat[y])):
				mat[y][x] = ' '
			return

def plot_gene(stdscr, g):
	mat = B['mat']
	beg = B['beg']
	end = B['end']
	
	if g.beg >= beg and g.end <= end:
		pass
		# plot both sides
	elif g.beg >= beg and g.end > end:
		pass
		# plot beg, dash end
	elif g.beg < beg and g.end < end:
		pass
		# plot end, dash beg
	elif g.beg < beg and g.end > end:
		pass
		# both side are dashed
	elif g.beg < beg and g.end < beg:
		return
	elif g.beg > end and g.end > end:
		return
	else:
		raise KandiError('should not be possible')	
		
		
	
	# figure out where the text will be horizontally
	# find a place to insert gene
		# always plot transcripts below parent gene
	
	
	
	"""
	for y in range(len(mat)):
		clear = True
		for x in range(len(mat[y])):
			if mat[y][x]:
				clear = False
				break
		if clear:
			stdscr.addstr(y+1, 0, '-' * B['w'], curses.color_pair(0))
			for x in range(len(mat[y])):
				mat[y][x] = ' '
			return
	"""

def plot_genes(stdscr):
	H, W = stdscr.getmaxyx()
	curses.flash()
	region = Feature(B['dna'], B['beg'], B['end'], '.', 'region')
	
	# reset the plotting matrix
	B['mat'] = []
	max_rows = H -2 # 2 rows reserved for header and footer 
	for y in range(max_rows):
		B['mat'].append([])
		for x in range(W):
			B['mat'][y].append([])
			B['mat'][y][x] = None
	
	# main plotting loop
	for i in range(len(F)):
	
		# plot source file name
		plot_text(stdscr, F[i], 4)
		#plot_divider(stdscr)

		# plot genes
		for genes in G[i]:
			for gene in genes:
				if region.overlap(gene):
					plot_gene(stdscr, gene)

def text_at_cursor():
	if B['mat']: return B['mat'][B['y']-1][B['x']]
	else: return None

def zoom(stdscr, scale):
	# assign new beg and end
	l1 = B['end'] - B['beg'] + 1
	m = (B['beg'] + B['end']) / 2
	z1 = B['end'] - m
	
	z2 = z1 * scale
	b2 = int(m - z2)
	e2 = int(m + z2)

	# constrain
	max = len(B['dna'].seq)
	if b2 < 1: b2 = 1
	if e2 > max: e2 = max

	# minimum zoom is 1
	l2 = e2 - b2 + 1
	if l2 < B['w']:
		if b2 == 1:
			e2 = B['w']
		elif e2 == max:
			b2 = max - B['w'] + 1
		else:
			e2 = b2 + B['w'] - 1
	l2 = e2 - b2 + 1
	
	B['z'] = l2 / B['w']
	B['beg'] = b2
	B['end'] = e2
	plot_genes(stdscr)

def update_state(stdscr):
	H, W = stdscr.getmaxyx()
	if B['p'] == None:
		B['beg'] = 1
		B['end'] = len(B['dna'].seq)
		B['x'] = int(W/2)
		B['y'] = int(H/4)
	
	B['w'] = W
	B['h'] = H
	L = B['end'] - B['beg'] + 1
	B['z'] = L / W
	
	B['p'] = 1 + int(B['x'] * B['z'])

	foc = None
	if B['z'] == 1:
		foc = '{} : {}'.format(B['p'], text_at_cursor())
	else:
		foc = '{}-{} ({} bp) : {}'.format(
			B['p'],
			int(B['p'] + B['z'] -1),
			int(B['z']),
			text_at_cursor())
	
	stdscr.addstr(0, B['tab'], foc, curses.color_pair(1))
	stdscr.addstr(0, B['tab'] + len(foc), ' ' * (W - (B['tab'] + len(foc))))
	stdscr.move(B['y'], B['x'])

def terminal_changed(stdscr):
	h, w = stdscr.getmaxyx()
	if w != B['w'] or h != B['h']: return True
	else: return False

def view_screen(stdscr):

	# initial settings
	stdscr.clear()
	curses.curs_set(2)
	
	k = None	
	while True:
		# determine if we need to reconfigure viewing pane
		if terminal_changed(stdscr):
			update_state(stdscr)
			plot_genes(stdscr)

		# action
		if   k == ord('h'): help_screen(stdscr)
		elif k == ord('s'): select_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		elif k == 258: B['y'] = B['y'] + 1 # arrow down
		elif k == 259: B['y'] = B['y'] - 1 # arrow up
		elif k == 261: B['x'] = B['x'] + 1 # arrow right
		elif k == 402: B['x'] += int(B['w']/4)  # shift-arrow right
		elif k == 260: B['x'] = B['x'] - 1 # arrow left
		elif k == 393: B['x'] -= int(B['w']/4)  # shift-arrow left
		elif k == 10:  pass # set focus string
		elif k == ord('-'): zoom(stdscr, 2)   # zoom out
		elif k == ord('_'): zoom(stdscr, 8)   # zoom out a lot
		elif k == ord('='): zoom(stdscr, 1/2) # zoom in
		elif k == ord('+'): zoom(stdscr, 1/8) # zoom in a lot
		# space centers on cursor?
		
		# limit cursor bounds
		if B['x'] < 0:         B['x'] = 0
		if B['x'] > B['w'] -1: B['x'] = B['w'] -1
		if B['y'] < 1:         B['y'] = 1
		if B['y'] > B['h'] -2: B['y'] = B['h'] -2
				
		# location & menu
		stdscr.addstr(0, 0, ' ' * B['tab'], curses.color_pair(0))
		loc = '{}:{}-{} ({} bp)'.format(B['dna'].name, B['beg'], B['end'],
			B['end'] - B['beg'] + 1)
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(B['h']-1, 0, '(s)elector (h)elp (q)uit',
			curses.color_pair(1))
		update_state(stdscr)
		k = stdscr.getch()

def init_browser(stdscr):

	# initialize curses	and begin on the help page
	curses.start_color()
	curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
	curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
	curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
	curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
	curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)
	curses.init_pair(6, curses.COLOR_BLUE, curses.COLOR_BLACK)
	curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
	help_screen(stdscr)

def init_chrom(idx):

	# when a new chromosome is chosen, reset browser state
	B['idx'] = idx
	B['dna'] = D[idx]
	B['beg'] = None
	B['end'] = None
	B['p'] = None
	B['x'] = None
	B['y'] = None
	B['z'] = None
	B['w'] = None
	B['h'] = None

if __name__ == '__main__':

	# read sequences
	fasta = FASTA_stream(arg.fasta[0])
	for entry in fasta:
		D.append(DNA(name=entry.id, seq=entry.seq))
	
	# read features and build genes
	for i in range(len(arg.gff)):
		G.append([])
		F.append(arg.gff[i])
		gf = GFF_file(file=arg.gff[i])
		for dna in D:
			gffs = gf.get(chrom=dna.name)
			features = []
			for gff in gffs:
				features.append(gff_to_feature(dna, gff))	
			ft = FeatureTable(dna=dna, features=features)
			genes = ft.build_genes()
			G[i].append(genes)

	# initialize for first sequence
	init_chrom(0)

	# start the curses session
	curses.wrapper(init_browser)

