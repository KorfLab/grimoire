#!/usr/bin/env python3

import argparse
import sys
import os
import curses
import curses.textpad

from grimoire.sequence import DNA
from grimoire.feature_table import FeatureTable
from grimoire.io import FASTA_stream, GFF_file
from grimoire.genome import gff_to_feature
from grimoire.feature import Gene, mRNA, Feature

## Command line stuff ##

extended_help = """
%(prog)s is a very simple terminal-based genome browser designed for testing
and debugging seqeunce analysis algorithms. It loads all of the
sequences and features into memory and doesn't do any coordinate
indexing. It is therefore not suitable for complete genomes.
"""

parser = argparse.ArgumentParser(
	description='Terminal-based genome browser.',
	formatter_class=argparse.RawDescriptionHelpFormatter,
	epilog=extended_help)
parser.add_argument('fasta', nargs=1, help='a fasta file')
parser.add_argument('gff', nargs='+', help='some gff (or other) files')
arg = parser.parse_args()

#############
## Globals ##
#############

class KandiError(Exception): pass

D = []  # dnas: indexed in order of FASTA file
G = []  # genes: indexed by fasta# then gene#
F = []  # files: annotation file name
B = { # browser state
	'idx':None, # current dna object number
	'dna':None, # current dna object
	'beg':None, # begin coordinate of viewer window
	'end':None, # end coordinate of viewer window
	'mat':None, # matrix of screen contents
	'row':None, # next plottable row
	'up':False, # update required
	'x':None,   # cursor x position
	'y':None,   # cursor y position
	'z':None,   # size of cursor (in letters)
	'h':None,   # last height of terminal
	'w':None,   # last width of terminal
}

KANDI_HELP = """
 KANDI help screen

 General
 + The first line displays current location and context information
 + The bottom line displays menu items

 Selector
 + Use the up/down arrow keys to choose a sequence
 + Use the return key to select a sequence for browsing

 Browser
 + Use the arrow keys to move the cusor around
 + When the cursor is on a feature, there will be descriptive text at the top
 + Use the +/- keys to zoom
 + Add the shift key to make bigger steps (both left/right and zoom)
 + Use the return key to zoom in on the feature under cursor
"""

def terminal_changed(stdscr):
	h, w = stdscr.getmaxyx()
	if w != B['w'] or h != B['h']: return True
	elif B['up']: return True
	else: return False

def help_screen(stdscr):
	curses.curs_set(0)

	while True:
		stdscr.clear()
		H, W = stdscr.getmaxyx()
		
		# content
		stdscr.addstr(2, 1, KANDI_HELP)
	
		# location & menu
		loc = '{}:{}-{}'.format(B['dna'].name, B['beg'], B['end'])
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(H-1, 0, '(s)elector (v)iewer (q)uit',
			curses.color_pair(1))

		# action
		k = stdscr.getch()
		if   k == ord('s'): select_screen(stdscr)
		elif k == ord('v'): view_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		else: curses.flash()
		
def select_screen(stdscr):
	curses.curs_set(2)
	top = 4
	bot = top + len(D) -1
	B['x'] = 3
	B['y'] = top
	stdscr.move(B['y'], B['x'])
	k = None

	while True:
		stdscr.clear()
		H, W = stdscr.getmaxyx()
		
		# content
		stdscr.addstr(2, 1, 'KANDI chromosome selector.')	
		for i in range(len(D)):
			stdscr.addstr(4 + i, 4, D[i].name)
	
		# location & menu
		loc = '{}:{}-{}'.format(B['dna'].name, B['beg'], B['end'])
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(H-1, 0, '(b)rowser (h)elp (q)uit', curses.color_pair(1))

		# action
		if   k == ord('h'): help_screen(stdscr)
		elif k == ord('v'): view_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		elif k == 258: B['y'] = B['y'] + 1
		elif k == 259: B['y'] = B['y'] - 1
		elif k == 10:
			init_chrom(B['y'] - top)
			view_screen(stdscr)
		
		if B['y'] < top: B['y'] = top
		if B['y'] > bot: B['y'] = bot
		stdscr.move(B['y'], B['x'])
		k = stdscr.getch()

def find_clear_row():
	for y in range(len(B['mat'])):
		all_clear = True
		for x in range(0, B['w']):
			if B['mat'][y][x]:
				all_clear = False
				break
		if all_clear:
			B['row'] = y
			break

def text_at_cursor():
	if B['mat']:
		thing = B['mat'][B['y']-1][B['x']]
		if thing == None: return
		elif isinstance(thing, str): return thing
		elif isinstance(thing, Gene): return thing.id
		elif isinstance(thing, mRNA): return thing.id
		elif isinstance(thing, Feature):
			return '{}:{}-{}'.format(thing.type, thing.beg, thing.end)
	else: return None

def plot_header(stdscr, text, color):
	mat = B['mat']
	for y in range(B['row'], len(mat)):
		clear = True
		for x in range(B['w']):
			if mat[y][x]:
				clear = False
				break
		if clear:
			stdscr.addstr(y+1, 0, text, curses.color_pair(color))
			for x in range(B['w']): mat[y][x] = text
			return

def plot_feature(stdscr, f):
	rx1 = int(B['beg'] / B['z'])
	rx2 = int(B['end'] / B['z'])
	fx1 = int(f.beg / B['z']) - rx1
	fx2 = int(f.end / B['z']) - rx1
	
	min = 0
	max = B['w'] -1

	if fx1 < min and fx2 < min: return # don't plot out-of-bounds features
	if fx1 > max and fx2 > max: return

	compL = True
	compR = True
	if fx1 < min:
		fx1 = 0
		compL = False
	if fx2 > max:
		fx2 = max
		compR = False
	
	text = ''
	for i in range(fx1, fx2+1):
		text += '#'
	if compL: text = '[' + text[1:]
	if compR: text = text[:-1] + ']'
	if fx1 == fx2: text = '|'
	
	mat = B['mat']
	for y in range(B['row'], len(mat)):
		clear = True
		for x in range(fx1, fx2+1):
			if mat[y][x]:
				clear = False
				break
		if clear:
			c = None
			if   f.strand == '+': c = 5
			elif f.strand == '-': c = 7
			else:                 c = 4
			stdscr.addstr(y+1, fx1, text, curses.color_pair(c))
			for x in range(fx1, fx2+1):
				mat[y][x] = f
			break

def plot_ticks(stdscr):
	ticks = 10
	for i in range(ticks):
		x = int(i * B['w'] / ticks)
		p = B['beg'] + int(x * B['z'] + B['z']/2) + 1
		s = '{} {}'.format('|', p)
		stdscr.addstr(1 + B['row'], x, s, curses.color_pair(0))
	B['mat'][B['row']][0] = True

def plot_sequence(stdscr):
	seq = B['dna'].seq[B['beg']:B['end']+1]
	stdscr.addstr(1 + B['row'], 0, seq, curses.color_pair(0))
	B['mat'][B['row']][0] = True

def plot_genes(stdscr):
	H, W = stdscr.getmaxyx()
	curses.flash()
	stdscr.clear()
	region = Feature(B['dna'], B['beg'], B['end'], '.', 'region')
	
	# reset the plotting matrix
	B['mat'] = []
	B['row'] = 0
	max_rows = H -2 # 2 rows reserved for header and footer 
	for y in range(max_rows):
		B['mat'].append([])
		for x in range(W):
			B['mat'][y].append([])
			B['mat'][y][x] = None

	find_clear_row()
	plot_ticks(stdscr)
	if B['z'] == 1:
		find_clear_row()
		plot_sequence(stdscr)

	# main plotting loop
	for i in range(len(F)):
		find_clear_row()
		plot_header(stdscr, F[i], 4)
		B['row'] += 1
		for genes in G[i][B['idx']]:
			for gene in genes:
				plot_feature(stdscr, gene)

	B['up'] = False

def zoom(scale):
	B['up'] = True # will force replotting of genes
	
	# zoom in on cursor and reset its position
	c = B['beg'] + B['x'] * B['z'] + B['z']/2
	d = B['end'] - B['beg'] + 1
	beg = c - d * scale / 2
	end = c + d * scale / 2
	B['x'] = int(B['w'] / 2)

	# constrain
	max = len(B['dna'].seq)
	if beg < 1: beg = 1
	if end > max: end = max
	beg = int(beg)
	end = int(end)

	# minimum zoom is 1 bp
	L = end - beg + 1
	if L < B['w']:
		if beg == 1:
			end = B['w']
		elif end == max:
			beg = max - B['w'] + 1
		else:
			end = beg + B['w'] - 1
	L = end - beg + 1
	
	B['z'] = L / B['w']
	B['beg'] = int(beg)
	B['end'] = int(end)

def update_state(stdscr):
	H, W = stdscr.getmaxyx()
	B['w'] = W
	B['h'] = H
	L = B['end'] - B['beg'] + 1
	B['z'] = L / W
	
	foc = None
	if B['z'] == 1:
		foc = '{} : {}'.format(B['beg'] + B['x'] +1, text_at_cursor())
	else:
		x1 = int(B['beg'] + B['x'] * B['z'])
		x2 = int(B['beg'] + (B['x']+1) * B['z'] -1)
		foc = '{}-{} ({} bp) : {}'.format(
			x1, x2, int(B['z']), text_at_cursor())
	
	stdscr.addstr(0, int(B['w']/2), foc, curses.color_pair(1))
	stdscr.addstr(0,int(B['w']/2) + len(foc), ' ' * (W - (int(B['w']/2) + len(foc))))
	
def view_screen(stdscr):

	# initial settings
	H, W = stdscr.getmaxyx()
	B['beg'] = 1
	B['end'] = len(B['dna'].seq)
	B['x'] = int(W/2)
	B['y'] = int(H/4)
	B['w'] = W
	B['h'] = H
	stdscr.clear()
	curses.curs_set(2)
	update_state(stdscr)
	plot_genes(stdscr)
	
	k = None	
	while True:

		# action
		if   k == ord('h'): help_screen(stdscr)
		elif k == ord('s'): select_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		elif k == 258: B['y'] += 1    # arrow down
		elif k == 259: B['y'] -= 1    # arrow up
		elif k == 261: B['x'] += 1    # arrow right
		elif k == 402: B['x'] += 20   # shift-arrow right
		elif k == 260: B['x'] -= 1    # arrow left
		elif k == 393: B['x'] -= 20   # shift-arrow left
		elif k == 10:  pass # set zoom on feature?
		elif k == ord('-'): zoom(2)   # zoom out
		elif k == ord('_'): zoom(8)   # zoom out a lot
		elif k == ord('='): zoom(1/2) # zoom in
		elif k == ord('+'): zoom(1/8) # zoom in a lot
		elif k == 32: zoom(1)
		
		# limit cursor bounds
		if B['x'] < 0:
			B['x'] = 0
			zoom(1)
		elif B['x'] > B['w'] -1:
			B['x'] = B['w'] -1
			zoom(1)
		if B['y'] < 1:
			B['y'] = 1
		elif B['y'] > B['h'] -2:
			B['y'] = B['h'] -2
		
		# determine if we need to reconfigure viewing pane
		if terminal_changed(stdscr):
			stdscr.clear()
			update_state(stdscr)
			plot_genes(stdscr)
				
		# location & menu
		stdscr.addstr(0, 0, ' ' * int(B['w']/2), curses.color_pair(0))
		loc = '{}:{}-{} ({} bp)'.format(B['dna'].name, B['beg'], B['end'],
			B['end'] - B['beg'] + 1)
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(B['h']-1, 0, '(s)elector (h)elp (q)uit',
			curses.color_pair(1))
		update_state(stdscr)
		stdscr.move(B['y'], B['x'])
		k = stdscr.getch()

def init_browser(stdscr):

	# initialize curses	and begin on the help page
	curses.start_color()
	curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
	curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
	curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
	curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
	curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)
	curses.init_pair(6, curses.COLOR_BLUE, curses.COLOR_BLACK)
	curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
	view_screen(stdscr)

def init_chrom(idx):

	# when a new chromosome is chosen, reset browser state
	B['idx'] = idx
	B['dna'] = D[idx]
	B['beg'] = 1
	B['end'] = len(D[idx].seq)
	B['x'] = None
	B['y'] = None
	B['z'] = None
	B['w'] = None
	B['h'] = None

if __name__ == '__main__':

	# read sequences
	fasta = FASTA_stream(arg.fasta[0])
	for entry in fasta:
		D.append(DNA(name=entry.id, seq=entry.seq))
	
	# read features and build genes
	for i in range(len(arg.gff)):
		G.append([])
		F.append(arg.gff[i])
		gf = GFF_file(file=arg.gff[i])
		for j in range(len(D)):
			dna = D[j]
			G[i].append([])
			gffs = gf.get(chrom=dna.name)
			features = []
			for gff in gffs:
				features.append(gff_to_feature(dna, gff))	
			ft = FeatureTable(dna=dna, features=features)
			genes = ft.build_genes()
			G[i][j].append(genes)

	# initialize for first sequence
	init_chrom(0)

	# start the curses session
	curses.wrapper(init_browser)

