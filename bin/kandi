#!/usr/bin/env python3

import argparse
import sys
import os
import curses
import curses.textpad

from grimoire.sequence import DNA
from grimoire.feature_table import FeatureTable
from grimoire.io import FASTA_stream, GFF_file
from grimoire.genome import gff_to_feature

## Command line stuff ##

extended_help = """
%(prog)s is a very simple terminal-based genome browser designed for testing
and debugging seqeunce analysis algorithms. It loads all of the
sequences and features into memory and doesn't do any coordinate
indexing. It is therefore not suitable for complete genomes.
"""

parser = argparse.ArgumentParser(
	description='Terminal-based genome browser.',
	formatter_class=argparse.RawDescriptionHelpFormatter,
	epilog=extended_help)
parser.add_argument('fasta', nargs=1, help='a fasta file')
parser.add_argument('gff', nargs='+', help='some gff (or other) files')
arg = parser.parse_args()

#############
## Globals ##
#############

D = []  # dnas: indexed in order of FASTA file
G = []  # genes: indexed by fasta# then gene#
B = { # browser state
	'dna':None, # current dna object number
	'beg':None, # begin coordinate of viewer window
	'end':None, # end coordinate of viewer window
	'tab':40,   # tab stop for focus data
	'p':None,   # approximate position of the cursor in sequence coordinates
	'x':None,   # cursor x position
	'y':None,   # cursor y position
	'z':None,   # size of cursor (in letters)
	'h':None,   # last height of terminal
	'w':None,   # last width of terminal
}

KANDI_HELP = """
 KANDI help screen

 General
 + The top line displays current location and context information
 + The bottom line displays menu items

 Selector
 + Use the up/down arrow keys to choose a sequence
 + Use the return key to select a sequence for browsing

 Browser
 + Use the arrow keys to move the cusor around
 + When the cursor is on a feature, there will be descriptive text at the top
 + Use the +/- keys to zoom
 + Add the shift key to make bigger steps (both left/right and zoom)
 + Use the return key to zoom in on the feature under cursor
"""

def help_screen(stdscr):
	curses.curs_set(0)

	while True:
		stdscr.clear()
		H, W = stdscr.getmaxyx()
		
		# content
		stdscr.addstr(2, 1, KANDI_HELP)
	
		# location & menu
		loc = '{}:{}-{}'.format(B['dna'].name, B['beg'], B['end'])
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(H-1, 0, '(s)elector (v)iewer (q)uit',
			curses.color_pair(1))

		# action
		k = stdscr.getch()
		if   k == ord('s'): select_screen(stdscr)
		elif k == ord('v'): view_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		else: curses.flash()
		
def select_screen(stdscr):
	curses.curs_set(2)
	top = 4
	bot = top + len(D) -1
	B['x'] = 3
	B['y'] = top
	stdscr.move(B['y'], B['x'])
	k = None

	while True:
		stdscr.clear()
		H, W = stdscr.getmaxyx()
		
		# content
		stdscr.addstr(2, 1, 'KANDI chromosome selector.')	
		for i in range(len(D)):
			stdscr.addstr(4 + i, 4, D[i].name)
	
		# location & menu
		loc = '{}:{}-{}'.format(B['dna'].name, B['beg'], B['end'])
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(H-1, 0, '(b)rowser (h)elp (q)uit', curses.color_pair(1))

		# action
		if   k == ord('h'): help_screen(stdscr)
		elif k == ord('v'): view_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		elif k == 258: B['y'] = B['y'] + 1
		elif k == 259: B['y'] = B['y'] - 1
		elif k == 10:
			init_chrom(B['y'] - top)
			view_screen(stdscr)
		
		if B['y'] < top: B['y'] = top
		if B['y'] > bot: B['y'] = bot
		stdscr.move(B['y'], B['x'])
		k = stdscr.getch()

def plot_genes(stdscr):
	pass
	
	"""
	# plotting matrix setup
		mat = []
		max_rows = H -2 # 2 rows reserved for header and footer 
		for y in range(max_rows):
			mat.append([])
			for x in range(W):
				mat[y].append([])
				mat[y][x] = None

		for gene in STATE['g1']:
			c = 5 # color
			if gene.strand == '-': c = 7
			beg, end = None, None
			if gene.beg > STATE['beg'] and gene.beg < STATE['end']:
				beg = int(gene.beg / scale)
			if gene.end > STATE['beg'] and gene.end < STATE['end']:
				end = int(gene.end / scale)
			if not (beg or end): continue

			for y in range(max_rows):
				if beg == end:
					if mat[y][beg] == None:
						mat[y][beg] = gene
						stdscr.addstr(y+2, beg, '|', curses.color_pair(c))
						break
				elif beg and end:
					clear = True
					for x in range (beg, end+1):
						if mat[y][x] != None:
							clear = False
							break
					if not clear: continue
					for x in range (beg, end+1): mat[y][x] = gene
					stdscr.addstr(y+2, beg, '[', curses.color_pair(c))
					for i in range (beg+1, end):
						stdscr.addstr(y+2, i, '=', curses.color_pair(c))
					stdscr.addstr(y+2, end, ']', curses.color_pair(c))
					break
				elif beg:
					pass
				elif end:
					pass
	"""

def feature_at_cursor():
	return 'stuff'
	# non-indexed search through genes and features

def zoom(X):
	L = B['end'] - B['beg'] + 1
	M = B['beg'] + L / 2
	L2 = L * X / 2
	beg = M - L2
	end = M + L2
	
	max = len(B['dna'].seq)
	if beg < 1: beg = 1
	if end > max: end = max
	
	L = end - beg + 1
	M = beg + L / 2
	if L < B['w']:
		beg = M - B['w'] / 2
		end = M + B['w'] / 2
	
	B['beg'] = int(beg)
	B['end'] = int(end)

def update_state(stdscr):
	H, W = stdscr.getmaxyx()
	if B['p'] == None:
		B['beg'] = 1
		B['end'] = len(B['dna'].seq)
		B['x'] = int(W/2)
		B['y'] = int(H/4)
	B['z'] = int((B['end'] - B['beg'] + 1) / W)
	B['p'] = 1 + int(B['x'] * B['z'])
	B['w'] = W
	B['h'] = H
	ftext = feature_at_cursor()
	foc = '{}-{} ({} bp): {}'.format(
		B['p'],
		int(B['p'] + B['z'] -1),
		int(B['z']),
		ftext)
	stdscr.addstr(0, B['tab'], foc, curses.color_pair(5))
	stdscr.addstr(0, B['tab'] + len(foc), ' ' * (W - (B['tab'] + len(foc))))
	stdscr.move(B['y'], B['x'])
		
def terminal_changed(stdscr):
	h, w = stdscr.getmaxyx()
	if w != B['w'] or h != B['h']: return True
	else: return False

def view_screen(stdscr):

	# initial settings
	stdscr.clear()
	curses.curs_set(2)
	
	k = None	
	while True:
		# determine if we need to reconfigure viewing pane
		if terminal_changed(stdscr):
			update_state(stdscr)
			plot_genes(stdscr)
		
		# location & menu
		stdscr.addstr(0, 0, ' ' * B['tab'], curses.color_pair(0))
		loc = '{}:{}-{} ({} bp)'.format(B['dna'].name, B['beg'], B['end'],
			B['end'] - B['beg'])
		stdscr.addstr(0, 0, loc, curses.color_pair(1))
		stdscr.addstr(B['h']-1, 0, '(s)elector (h)elp (q)uit',
			curses.color_pair(1))

		# action
		if   k == ord('h'): help_screen(stdscr)
		elif k == ord('s'): select_screen(stdscr)
		elif k == ord('q'): sys.exit(0)
		elif k == 258: B['y'] = B['y'] + 1 # arrow down
		elif k == 259: B['y'] = B['y'] - 1 # arrow up
		elif k == 261: B['x'] = B['x'] + 1 # arrow right
		elif k == 402: B['x'] += int(B['w']/4)  # shift-arrow right
		elif k == 260: B['x'] = B['x'] - 1 # arrow left
		elif k == 393: B['x'] -= int(B['w']/4)  # shift-arrow left
		elif k == 10:  pass # set focus string
		elif k == ord('-'): zoom(2)   # zoom out
		elif k == ord('_'): zoom(4)   # zoom out a lot
		elif k == ord('='): zoom(1/2) # zoom in
		elif k == ord('+'): zoom(1/4) # zoom in a lot
		
		# limit cursor bounds
		if B['x'] < 0:         B['x'] = 0
		if B['x'] > B['w'] -1: B['x'] = B['w'] -2
		if B['y'] < 1:         B['y'] = 1
		if B['y'] > B['h'] -2: B['y'] = B['h'] -2
				
		# save state
		update_state(stdscr)
		k = stdscr.getch()

def init_browser(stdscr):

	# initialize curses	and begin on the help page
	curses.start_color()
	curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
	curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
	curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
	curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
	curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)
	curses.init_pair(6, curses.COLOR_BLUE, curses.COLOR_BLACK)
	curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
	help_screen(stdscr)

def init_chrom(idx):

	# when a new chromosome is chosen, reset browser state
	B['dna'] = D[idx]
	B['beg'] = None
	B['end'] = None
	B['p'] = None
	B['x'] = None
	B['y'] = None
	B['z'] = None
	B['w'] = None
	B['h'] = None
	
if __name__ == '__main__':

	# read sequences
	fasta = FASTA_stream(arg.fasta[0])
	for entry in fasta:
		D.append(DNA(name=entry.id, seq=entry.seq))
	
	# read features and build genes
	for i in range(len(arg.gff)):
		G.append([])
		gf = GFF_file(file=arg.gff[i])
		for dna in D:
			gffs = gf.get(chrom=dna.name)
			features = []
			for gff in gffs:
				features.append(gff_to_feature(dna, gff))	
			ft = FeatureTable(dna=dna, features=features)
			genes = ft.build_genes()
			G[i].append(genes)

	# initialize for first sequence
	init_chrom(0)

	# start the curses session
	curses.wrapper(init_browser)

