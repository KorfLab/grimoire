#!/usr/bin/env python3

import argparse
import json
import random
import sys

from grimoire.hmm import HMM

## Command Line ##

parser = argparse.ArgumentParser(description='Random sequence generator')
parser.add_argument('--alphabet', required=True, type=str, metavar='<str>',
    help='alphabet of desiring sequences: nt | aa')
parser.add_argument('--alp_type', required=False, type=str, metavar='<str>',
    default="canonical", help='canonical | extended')
parser.add_argument('--end_state', required=False, type=str, default="none",
	metavar='<str>', help='the specific state to end with')
parser.add_argument('--length', required=True, type=int,
	metavar='<int>', help='length of desiring sequences')
parser.add_argument('--source', required=True, type=str,
	metavar='<path>', help='path to source HMM model (%(type)s)')
parser.add_argument('--start_state', required=False, type=str, default="none",
	metavar='<str>', help='the specific state to begin with')
parser.add_argument('--trial', required=False, type=int, default=1,
	metavar='<int>', help='amount of trials acceptable to generate sequence')
arg = parser.parse_args()

####################
# Global Variables #
####################
if arg.alphabet == 'nt':
    if arg.alp_type == 'canonical':
        Alphabet = ['A', 'C', 'G', 'T']
    elif arg.alp_type == 'extended':
        Alphabet =  ['A', 'C', 'G', 'T', 'R', 'Y', 'M', 'K', 'W', 'S', 'B', 'D',
            'H', 'V', 'N']
elif arg.alphabet == 'aa':
    if arg.alp_type == 'canonical':
        Alphabet = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N',
            'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']
    elif arg.alp_type == 'extended':
        Alphabet =  ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N',
            'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'X', '*']
Model = HMM.read(arg.source)


####################
#### Functions #####
####################

class Random_Seq:

    def __init__(self, model, alphabet, length, starter="none", ender="none"):
        self.model = model
        if self.model["log"] == True:
            print("Error: log == True")
        self.alphabet = alphabet
        self.length = length
        self.start = {}
        self.end = {}
        for n in range(len(self.model["states"])):
            if self.model["states"][n]["init"] > 0:
                v = self.model["states"][n]["init"]
                self.start[self.model["states"][n]["name"]] = v
            if self.model["states"][n]["term"] > 0:
                v = self.model["states"][n]["term"]
                self.end[self.model["states"][n]["name"]] = v
        self.starter = starter
        self.ender = ender

    def _rand(self):
        x = random.randint(0, len(self.alphabet) - 1)
        return self.alphabet[x]

    def _find(self, name):
        for n in range(len(self.model["states"])):
            if self.model["states"][n]["name"] == name:
                return n

    def _get(self,dict):
        sum = 0
        x = random.uniform(0.00, 1.00)
        for s in dict:
            sum += dict[s]
            if sum >= x:
                return s
        raise Exception

    def _check(self,state_seq, cur_name, ctxt):
        for i in range(-(ctxt),0,1):
            if state_seq[i] != cur_name:
                return False
        return True

    def generate_null(self):
        seq = []
        while len(seq) < self.length:
            seq.append(self._get(self.model["null"]["emit"]))
        seq = ''.join(seq)
        return seq


    def generate(self, trial):
        if self.ender == "none":
            free_end = True
        else:
            free_end = False
        stat = []
        seq = []
        if self.starter != "none":
            start = self.starter
        else:
            start = self._get(self.start)
        cur = self._find(start)
        cur_name = start
        ctxt = self.model["states"][cur]["ctxt"]
        stat.append(cur_name)
        if ctxt == 0:
            seq.append(self._get(self.model[cur]["emit"]))
        else:
            seq.append(self._rand())

        while len(stat) < self.length:
            st = self._get(self.model["states"][cur]["next"])
            if st != cur_name:
                cur =  self._find(st)
                ctxt = self.model["states"][cur]["ctxt"]
            enough = self._check(stat, st, ctxt)
            stat.append(st)
            if ctxt == 0:
                seq.append(self._get(self.model["states"][cur]["emit"]))
            elif enough:
                temp_pre =[]
                for i in range(-(ctxt),0,1):
                    temp_pre.append(seq[i])
                prefix = ''.join(temp_pre)
                try:
                    seq.append(self._get(self.model["states"][cur]["emit"][prefix]))
                except:
                    seq.append(self._rand())
            else:
                seq.append(self._rand())
        seq = ''.join(seq)
        if free_end == True:
            return stat, seq
        else:
            if self.ender != "none":
                end = self.ender
            else:
                end = self._get(self.end)
            if stat[-1] != end:
                trial -= 1
                if trial == 0:
                    print("Error: More Trilas?")
                    return [], ''
                else:
                    stat, seq = self.generate(self, free_end, trial)
            return stat, seq

####################
####### Main #######
####################

Seq = Random_Seq(model = Model, alphabet = Alphabet, length = arg.length,
    starter = arg.start_state, ender = arg.end_state)
q = Seq.generate_null()
print("null:")
print(q)
q,b = Seq.generate(trial = arg.trial)
print("state:")
print(q,b)
