#!/usr/bin/env python3

import argparse
import sys
import json
import copy

import grimoire.toolbox as toolbox
import grimoire.hmm as hmm
import grimoire.decode as decode
from grimoire.sequence import DNA
from grimoire.genome import Genome, Feature, mRNA, ProteinCodingGene

## Command line stuff ##

parser = argparse.ArgumentParser(description='HMM trainer for genes')
parser.add_argument('--fasta', required=True, type=str,
	metavar='<path>', help='path to fasta file (%(type)s)')
parser.add_argument('--gff3', required=True, type=str,
	metavar='<path>', help='path to GFF3 file (%(type)s)')
parser.add_argument('--model', required=True, type=str,
	metavar='<model>', help='internal_exon|splicing|mRNA')
parser.add_argument('--padding', required=False, type=int, default=100,
	metavar='<int>', help='length of flanking sequence [%(default)d]')
parser.add_argument('--hmm', required=False, type=str,
	metavar='<path>', help='output HMM file (%(type)s)')
parser.add_argument('--source', required=False, type=str,
	metavar='<name>', help='output sources to <name>.fasta, <name>.gff (%(type)s)')
parser.add_argument('--null_ctx', required=False, type=int, default=0,
	metavar='<int>', help='null model context [%(default)d]')
parser.add_argument('--acc_len', required=False, type=int, default=5,
	metavar='<int>', help='acceptor length [%(default)d]')
parser.add_argument('--acc_ctx', required=False, type=int, default=0,
	metavar='<int>', help='acceptor context [%(default)d]')
parser.add_argument('--don_len', required=False, type=int, default=5,
	metavar='<int>', help='donor length [%(default)d]')
parser.add_argument('--don_ctx', required=False, type=int, default=0,
	metavar='<int>', help='donor context [%(default)d]')
parser.add_argument('--exon_ctx', required=False, type=int, default=0,
	metavar='<int>', help='exon context [%(default)d]')
parser.add_argument('--gen_ctx', required=False, type=int, default=0,
	metavar='<int>', help='genomic context [%(default)d]')
parser.add_argument('--int_ctx', required=False, type=int, default=0,
	metavar='<int>', help='intron context [%(default)d]')
parser.add_argument('--u5_len', required=False, type=int, default=5,
	metavar='<int>', help='UTR5 length [%(default)d]')
parser.add_argument('--u5_ctx', required=False, type=int, default=0,
	metavar='<int>', help='UTR5 context [%(default)d]')
parser.add_argument('--u3_len', required=False, type=int, default=5,
	metavar='<int>', help='UTR3 length [%(default)d]')
parser.add_argument('--u3_ctx', required=False, type=int, default=0,
	metavar='<int>', help='UTR3 context [%(default)d]')
parser.add_argument('--koz_len', required=False, type=int, default=5,
	metavar='<int>', help='Kozak length [%(default)d]')
parser.add_argument('--koz_ctx', required=False, type=int, default=0,
	metavar='<int>', help='Kozak context [%(default)d]')
parser.add_argument('--atg_ctx', required=False, type=int, default=0,
	metavar='<int>', help='ATG context [%(default)d]')
parser.add_argument('--cds_ctx', required=False, type=int, default=0,
	metavar='<int>', help='CDS context [%(default)d]')
parser.add_argument('--xvalid', required=False, type=int, default=1,
	metavar='<int>', help='CDS context [%(default)d]')
#parser.add_argument('--replicant', action='store_true',
#	help='perform replicant analysis (model vs source)')
arg = parser.parse_args()


###############
## Functions ##
###############

class ForgeError(Exception):
	pass

def chromify(feature, beg, end):
	dna = DNA(seq=feature.dna.seq[beg:end], name=feature.id + '-remapped')
	gene = ProteinCodingGene(dna, feature.beg -beg, feature.end -beg,
		feature.strand, 'gene', id=feature.parent_id)
	tx = mRNA(dna, feature.beg -beg, feature.end -beg,
		feature.strand, 'mRNA', id=feature.id, parent_id=gene.id)
	for child in feature.children:
		tx.add_child(Feature(dna, child.beg -beg, child.end -beg,
			child.strand, child.type, parent_id=child.parent_id))
	gene.add_child(tx)
	dna.features.append(gene)
	if feature.strand == '-': dna.revcomp()
	return dna

def make_states(comps):
	single = ['int', 'exon', 'ut5', 'ut3']
	multi = ['acc', 'don', 'koz', 'atg', 'stop']
	cds = ['cds']
	group = []
	for comp in comps:
		(type, label, seqs, ctx, sst) = comp
		if type in single:
			emits = hmm.train_emission(seqs, ctx)
			state = hmm.State(name=label, context=ctx, emits=emits)
		elif type in multi:
			emits = hmm.train_emissions(seqs, ctx)
			states = hmm.state_factory(label, emits)
			hmm.connect_all(states)
		elif type in cds:
			emits = hmm.train_cds(seqs, ctx)
			states = hmm.state_factory('CDS', emits)
			hmm.connect_all(states)
		else:
			raise ForgeError('unknown type')
		
	raise ForgeError('must create null and genomic models')
	return model

#############
## Globals ##
#############

dataset = [] # data source organized by set number
for n in range(arg.xvalid): dataset.append([])

############################
## Build Mini-Chromosomes ##
############################

gene_count = 0
gen = Genome(gff3=arg.gff3, fasta=arg.fasta)
for chr in gen.chromosomes:
	for gene in chr.features:
		if not gene.mRNAs(): continue # some tx are miRNA etc
		tx = gene.mRNAs()[0]
		if tx.issues: continue
		rbeg = tx.beg - arg.padding
		rend = tx.end + arg.padding
		if rbeg < 1 or rend > len(chr.seq): continue
		
		dna = chromify(tx, rbeg, rend)
		n = gene_count % arg.xvalid
		dataset[n].append(dna)
		gene_count += 1

if arg.source:
	for n in range(arg.xvalid):
		setname = ''
		if (arg.xvalid != 1): setname = '-set' + str(n)
		with open(arg.source + setname + '.fasta', 'w+') as file:
			for dna in dataset[n]: file.write(dna.fasta())
		with open(arg.source + setname + '.gff3', 'w+') as file:
			for dna in dataset[n]: file.write(dna.features[0].gff())

##########################
## Gather Sub-Sequences ##
##########################

for i in range(len(dataset)):
	training = []
	testing = []
	if arg.xvalid == 1:
		training = dataset[0]
		testing = dataset[0]
	else:
		for j in range(len(dataset)):
			if i == j: testing = dataset[i]
			else:      training += dataset[i]
	
	acc_seqs = [] # splice acceptors
	don_seqs = [] # splice donors
	exn_seqs = [] # exons, the whole thing
	int_seqs = [] # introns, minus the acceptor and donors
	cds_seqs = [] # coding sequence
	koz_seqs = [] # kozak-ish sequence (upstream of atg)
	ut5_seqs = [] # 5'UTR
	ut3_seqs = [] # 3'UTR
	atg_seqs = [] # translation start, which may not always be atg
	stp_seqs = [] # translation end, usually TAA|TAG|TGA
		
	exn_len = 0
	int_len = 0
	ut5_len = 0
	ut3_len = 0
	splices = 0
	mRNAs = 0
	
	for dna in training:
		gene = dna.features[0]
		mRNA = gene.mRNAs()[0]
		
		# exon
		for exon in mRNA.exons:
			exn_seqs.append(exon.seq_str())
			exn_len += exon.length
		
		# intron & splice sites
		for intron in mRNA.introns:
			seq = intron.seq_str()
			don_seqs.append(seq[0:arg.don_len])
			int_seqs.append(seq[arg.don_len:-arg.acc_len])
			acc_seqs.append(seq[-arg.acc_len:len(seq)])
			splices += 1

		# mRNA-based sequences
		cds = tx.cds_str()
		ptx = tx.tx_str()
		beg = ptx.find(cds)
		end = beg + len(cds)
		
		# should these be here?
		if beg < arg.u5_ctx + arg.koz_len: continue
		if len(ptx) - end < arg.u3_ctx: continue
			
		ut5_seq = ptx[0 : beg - arg.koz_len]
		koz_seq = ptx[beg-arg.koz_len:beg]
		atg_seq = cds[0:3]
		stp_seq = cds[-3:]
		cds_seq = cds[3:]
		ut3_seq = ptx[end:]
			
		ut5_seqs.append(ut5_seq)
		koz_seqs.append(koz_seq)
		atg_seqs.append(atg_seq)
		cds_seqs.append(cds_seq)
		stp_seqs.append(stp_seq)
		ut3_seqs.append(ut3_seq)
		
		exn_len += len(exn_seq)
		cds_len += len(cds_seq)
		int_len += len(int_seq)
		ut5_len += len(ut5_seq)
		ut3_len += len(ut3_seq)
		cds_len += len(cds) - 3
		mRNAs += 1

	model = None
	if arg.model == 'internal_exon':
		ii = int_len / len(int_seqs)
		print(int_len, len(int_seqs))
		ee = 1 - 1 /(exn_len / len(exn_seqs))
		model = make_model([
			['int',  'INTa', int_seqs, arg.int_ctx,  ii],
			['acc',  'ACC',  acc_seqs, arg.acc_ctx,  0],
			['exon', 'EXON', exn_seqs, arg.exon_ctx, ee],
			['don',  'DON',  don_seqs, arg.don_ctx,  0],
			['int',  'INTb', int_seqs, arg.int_ctx,  ii],
			['null', 'NULL', chr_seqs, arg.null_ctx, 1]])
	elif arg.model == 'splicing':
		pass
	elif arg.model == 'mRNA':
		pass
	else:
		raise ForgeError('unknown model type: ' + arg.model)

"""
if arg.model == 'internal_exon':
	gen = Genome(gff3=arg.gff3, fasta=arg.fasta)
	acc_seqs = []
	don_seqs = []
	exon_seqs = []
	exon_len = 0
	splices = 0
	
	for chr in gen.chromosomes:
		for gene in chr.features:
			if not gene.mRNAs(): continue # some tx are miRNA etc
			tx = gene.mRNAs()[0]
			if gene.issues: continue
			if len(gene.mRNAs()) > 1: continue
			if len(tx.exons) < 3: continue
			
			rcount = 0
			for i in range(1, len(tx.exons) -1):
				iprev = tx.introns[i-1].seq_str()
				inext = tx.introns[i].seq_str()
				
				acc_seq = iprev[-arg.acc_len:len(iprev)]
				exon_seq = tx.exons[i].seq_str()
				don_seq = inext[0:arg.don_len]
				
				acc_seqs.append(acc_seq)
				exon_seqs.append(exon_seq)
				don_seqs.append(don_seq)
				
				splices += 1
				exon_len += tx.exons[i].end - tx.exons[i].beg + 1
				
				if arg.source or arg.replicant:
					rcount += 1
					sources.append(make_source(tx.id + '-region-' + str(rcount),
						[{'label':'ACC', 'seq':acc_seq},
						{'label':'EXON', 'seq':exon_seq},
						{'label':'DON', 'seq':don_seq}]))

	acc_emits = hmm.train_emissions(acc_seqs, context=arg.acc_ctx)
	don_emits = hmm.train_emissions(don_seqs, context=arg.don_ctx)
	exon_emits = hmm.train_emission(exon_seqs, context=arg.exon_ctx)
	
	acc_states = hmm.state_factory('ACC', acc_emits)
	don_states = hmm.state_factory('DON', don_emits)
	exon_state = hmm.State(name='EXON', context=arg.exon_ctx, emits=exon_emits)
	acc_states[0].init = 1
	don_states[arg.don_len-1].term = 1

	hmm.connect_all(acc_states)
	hmm.connect2(acc_states[-1], exon_state, 1)
	hmm.connect2(exon_state, exon_state, 1 - splices/exon_len)
	hmm.connect2(exon_state, don_states[0], splices/exon_len)
	hmm.connect_all(don_states)
	
	null_emits = hmm.train_emission(chr.seq, context=arg.null_ctx)	
	null_state = hmm.State(name='NULL', context=arg.null_ctx, emits=null_emits)
	null_state.init = 1
	null_state.term = 1
	hmm.connect2(null_state, null_state, 1)
	
	model = hmm.HMM(name=arg.hmm, states=acc_states + [exon_state] + don_states,
		null = null_state)

elif arg.model == 'splicing':
	gen = Genome(gff3=arg.gff3, fasta=arg.fasta)
	exp_seqs = []
	exn_seqs = []
	don_seqs = []
	acc_seqs = []
	int_seqs = []
	txa = []
	exon_len = 0
	splices = 0
	intron_len = 0
	for chr in gen.chromosomes:
		for gene in chr.features:
			if not gene.mRNAs(): continue # some tx are miRNA etc
			tx = gene.mRNAs()[0]
			if gene.issues: continue
			if len(gene.mRNAs()) > 1: continue
			if len(tx.exons) < 2: continue
			
			rcount = 0
			for i in range(len(tx.exons) - 1):
				exp_seq = tx.exons[i].seq_str()
				exn_seq = tx.exons[i + 1].seq_str()
				iseq = tx.introns[i].seq_str()
				don_seq = iseq[0:arg.don_len]
				int_seq = iseq[arg.don_len:-arg.acc_len]
				acc_seq = iseq[-arg.acc_len:len(iseq)]
				
				exp_seqs.append(exp_seq)
				don_seqs.append(don_seq)
				int_seqs.append(int_seq)
				acc_seqs.append(acc_seq)
				exn_seqs.append(exn_seq)
				
				intron_len += len(int_seq)
				exon_len += len(exp_seq)
				splices += 1
				
				if arg.source or arg.replicant:
					rcount += 1
					sources.append(make_source(tx.id + '-region-' + str(rcount),
						[{'label':'EXP', 'seq':exp_seq},
						{'label':'DON', 'seq':don_seq},
						{'label':'INT', 'seq':int_seq},
						{'label':'ACC', 'seq':acc_seq},
						{'label':'EXN', 'seq':exn_seq}]))
	
	exp_emits = hmm.train_emission(exp_seqs, context=arg.exon_ctx)
	don_emits = hmm.train_emissions(don_seqs, context=arg.don_ctx)
	int_emits = hmm.train_emission(int_seqs, context=arg.int_ctx)
	acc_emits = hmm.train_emissions(acc_seqs, context=arg.acc_ctx)
	exn_emits = hmm.train_emission(exn_seqs, context=arg.exon_ctx)
	
	exp_state = hmm.State(name='EXP', context=arg.exon_ctx, emits=exp_emits)
	exp_state.init = 1
	don_states = hmm.state_factory('DON', don_emits)
	int_state = hmm.State(name='INT', context=arg.int_ctx, emits=int_emits)
	acc_states = hmm.state_factory('ACC', acc_emits)
	exn_state = hmm.State(name='EXN', context=arg.exon_ctx, emits=exn_emits)
	exn_state.term = 1
	
	hmm.connect2(exp_state, exp_state, 1 - splices/exon_len)
	hmm.connect2(exp_state, don_states[0], splices/exon_len)
	hmm.connect_all(don_states)
	hmm.connect2(don_states[arg.don_len-1], int_state, 1)
	hmm.connect2(int_state, int_state, 1 - splices/intron_len)
	hmm.connect2(int_state, acc_states[0], splices/intron_len)
	hmm.connect_all(acc_states)
	hmm.connect2(acc_states[arg.acc_len-1], exn_state, 1)
	hmm.connect2(exn_state, exn_state, 1)
	
	null_emits = hmm.train_emission(chr.seq, context=arg.null_ctx)	
	null_state = hmm.State(name='NULL', context=arg.null_ctx, emits=null_emits)
	null_state.init = 1
	null_state.term = 1
	hmm.connect2(null_state, null_state, 1)
	
	model = hmm.HMM(name=arg.hmm, null=null_state,
		states=[exp_state] + don_states + [int_state] + acc_states + [exn_state])

elif arg.model == 'mRNA':
	gen = Genome(gff3=arg.gff3, fasta=arg.fasta)
	u5_seqs = []
	koz_seqs = []
	atg_seqs = []
	cds_seqs = []
	u3_seqs = []
	txa = []
	u5_len = 0
	mRNAs = 0
	cds_len = 0
	for chr in gen.chromosomes:
		for gene in chr.features:
			if not gene.mRNAs(): continue # some tx are miRNA etc
			tx = gene.mRNAs()[0]
			if gene.issues: continue
			if len(gene.mRNAs()) > 1: continue
			
			cds = tx.cds_str()
			ptx = tx.tx_str()
			beg = ptx.find(cds)
			end = beg + len(cds)
			if beg < arg.u5_ctx + arg.koz_len: continue
			if len(ptx) - end < arg.u3_ctx: continue
			
			u5_seq = ptx[0 : beg - arg.koz_len]
			koz_seq = ptx[beg-arg.koz_len:beg]
			atg_seq = cds[0:3]
			cds_seq = cds[3:len(cds)]
			u3_seq = ptx[end:len(ptx)]
			
			u5_seqs.append(u5_seq)
			koz_seqs.append(koz_seq)
			atg_seqs.append(atg_seq)
			cds_seqs.append(cds_seq)
			u3_seqs.append(u3_seq)
			
			u5_len += len(u5_seq)
			cds_len += len(cds) - 3
			mRNAs += 1
			
			if arg.source or arg.replicant:
				sources.append(make_source(tx.id + '-cDNA',
					[{'label':'UTR5', 'seq':u5_seq},
					{'label':'KOZ', 'seq':koz_seq},
					{'label':'ATG', 'seq':atg_seq},
					{'label':'CDS', 'seq':cds_seq},
					{'label':'UTR3', 'seq':u3_seq}]))

					
	u5_emits = hmm.train_emission(u5_seqs, context=arg.u5_ctx)
	koz_emits = hmm.train_emissions(koz_seqs, context=arg.koz_ctx)
	atg_emits = hmm.train_emissions(atg_seqs, context=arg.atg_ctx)
	cds_emits = hmm.train_cds(cds_seqs, context=arg.cds_ctx)
	u3_emits = hmm.train_emission(u3_seqs, context=arg.u3_ctx)
	
	u5_state = hmm.State(name='UTR5', context=arg.u5_ctx, emits=u5_emits)
	koz_states = hmm.state_factory('KOZ', koz_emits)
	atg_states = hmm.state_factory('ATG', atg_emits)
	cds_states = hmm.state_factory('CDS', cds_emits)
	u3_state = hmm.State(name='UTR3', context=arg.u3_ctx, emits=u3_emits)
	u5_state.init = 1
	u3_state.term = 1

	hmm.connect2(u5_state, u5_state, 1 - mRNAs/u5_len)
	hmm.connect2(u5_state, koz_states[0], mRNAs/u5_len)
	hmm.connect_all(koz_states)
	hmm.connect2(koz_states[-1], atg_states[0], 1)
	hmm.connect_all(atg_states)
	hmm.connect2(atg_states[-1], cds_states[0], 1)
	hmm.connect_all(cds_states)
	hmm.connect2(cds_states[2], cds_states[0], 1 - mRNAs / (cds_len/3))
	hmm.connect2(cds_states[2], u3_state, mRNAs / (cds_len/3))
	
	null_emits = hmm.train_emission(chr.seq, context=arg.null_ctx)	
	null_state = hmm.State(name='NULL', context=arg.null_ctx, emits=null_emits)
	null_state.init = 1
	null_state.term = 1
	hmm.connect2(null_state, null_state, 1)
	
	model = hmm.HMM(name=arg.hmm, states=[u5_state] + koz_states + atg_states
		+ cds_states + [u3_state], null=null_state)

else:
	raise ForgeError('unknown model type: ' + arg.model)

########################
## Post-build Actions ##
########################

if arg.hmm:
	model.write(arg.hmm)

if arg.source:
	with open(arg.source + '.fasta', 'w+') as file:
		for source in sources:
			file.write(source['dna'].fasta())
	with open(arg.source + '.gff', 'w+') as file:
		for source in sources:
			for f in source['features']:
				file.write(f.gff() + '\n')

if arg.replicant:
	model.convert2log() # note from here down, the model is log-space
	perf = decode.Performance(model)
	for source in sources:
		v = decode.Viterbi(model=model, dna=source['dna'])
		p = v.generate_path()
		features = p.features()
		perf.compare(source=source['features'], prediction=features)
	perf.report()
"""
