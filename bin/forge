#!/usr/bin/env python3

import argparse
import sys
import json
import copy

import grimoire.toolbox as toolbox
import grimoire.hmm as hmm
import grimoire.decode as decode
from grimoire.sequence import DNA
from grimoire.genome import Genome, Feature, mRNA, ProteinCodingGene

## Command line stuff ##

parser = argparse.ArgumentParser(description='HMM trainer for genes')
parser.add_argument('--fasta', required=True, type=str,
	metavar='<path>', help='path to fasta file (%(type)s)')
parser.add_argument('--gff3', required=True, type=str,
	metavar='<path>', help='path to GFF3 file (%(type)s)')
parser.add_argument('--model', required=True, type=str,
	metavar='<model>', help='internal_exon|splicing|mRNA')
parser.add_argument('--padding', required=False, type=int, default=100,
	metavar='<int>', help='length of flanking sequence [%(default)d]')
parser.add_argument('--hmm', required=False, type=str,
	metavar='<path>', help='output HMM file (%(type)s)')
parser.add_argument('--source', required=False, type=str,
	metavar='<name>', help='output sources to <name>.fasta, <name>.gff (%(type)s)')
parser.add_argument('--null_ctx', required=False, type=int, default=0,
	metavar='<int>', help='null model context [%(default)d]')
parser.add_argument('--acc_len', required=False, type=int, default=5,
	metavar='<int>', help='acceptor length [%(default)d]')
parser.add_argument('--acc_ctx', required=False, type=int, default=0,
	metavar='<int>', help='acceptor context [%(default)d]')
parser.add_argument('--don_len', required=False, type=int, default=5,
	metavar='<int>', help='donor length [%(default)d]')
parser.add_argument('--don_ctx', required=False, type=int, default=0,
	metavar='<int>', help='donor context [%(default)d]')
parser.add_argument('--exon_ctx', required=False, type=int, default=0,
	metavar='<int>', help='exon context [%(default)d]')
parser.add_argument('--gen_ctx', required=False, type=int, default=0,
	metavar='<int>', help='genomic context [%(default)d]')
parser.add_argument('--int_ctx', required=False, type=int, default=0,
	metavar='<int>', help='intron context [%(default)d]')
parser.add_argument('--u5_len', required=False, type=int, default=5,
	metavar='<int>', help='UTR5 length [%(default)d]')
parser.add_argument('--u5_ctx', required=False, type=int, default=0,
	metavar='<int>', help='UTR5 context [%(default)d]')
parser.add_argument('--u3_len', required=False, type=int, default=5,
	metavar='<int>', help='UTR3 length [%(default)d]')
parser.add_argument('--u3_ctx', required=False, type=int, default=0,
	metavar='<int>', help='UTR3 context [%(default)d]')
parser.add_argument('--koz_len', required=False, type=int, default=5,
	metavar='<int>', help='Kozak length [%(default)d]')
parser.add_argument('--koz_ctx', required=False, type=int, default=0,
	metavar='<int>', help='Kozak context [%(default)d]')
parser.add_argument('--atg_ctx', required=False, type=int, default=0,
	metavar='<int>', help='ATG context [%(default)d]')
parser.add_argument('--cds_ctx', required=False, type=int, default=0,
	metavar='<int>', help='CDS context [%(default)d]')
parser.add_argument('--xvalid', required=False, type=int, default=1,
	metavar='<int>', help='CDS context [%(default)d]')
arg = parser.parse_args()


###############
## Functions ##
###############

class ForgeError(Exception):
	pass

def chromify(feature, beg, end):
	dna = DNA(seq=feature.dna.seq[beg:end], name=feature.id + '-remapped')
	gene = ProteinCodingGene(dna, feature.beg -beg, feature.end -beg,
		feature.strand, 'gene', id=feature.parent_id)
	tx = mRNA(dna, feature.beg -beg, feature.end -beg,
		feature.strand, 'mRNA', id=feature.id, parent_id=gene.id)
	for child in feature.children:
		tx.add_child(Feature(dna, child.beg -beg, child.end -beg,
			child.strand, child.type, parent_id=child.parent_id))
	gene.add_child(tx)
	dna.features.append(gene)
	if feature.strand == '-': dna.revcomp()
	return dna

def make_model(name, comps):
	single = ['int', 'exon', 'ut5', 'ut3']
	multi = ['acc', 'don', 'koz', 'atg', 'stop']
	cds = ['cds']
	all_states = []
	for comp in comps:
		(type, label, seqs, ctx, init, term, sst) = comp
		if type in single:
			emits = hmm.train_emission(seqs, ctx)
			state = hmm.State(name=label, context=ctx, emits=emits)
			state.init = init
			state.term = term
			hmm.connect2(state, state, sst)
			all_states.append(state)
		elif type in multi:
			emits = hmm.train_emissions(seqs, ctx)
			states = hmm.state_factory(label, emits)
			hmm.connect_all(states)
			all_states += states
		elif type in cds:
			emits = hmm.train_cds(seqs, ctx)
			states = hmm.state_factory('CDS', emits)
			hmm.connect_all(states)
			all_states += states
		else:
			raise ForgeError('unknown type')
	
	for i in range(len(all_states)):
		sum = 0
		for s2 in all_states[i].next:
			sum += all_states[i].next[s2]
		if sum < 1 and i < len(all_states) -1:
			r = 1 - sum
			all_states[i].next[all_states[i+1].name] = r
	
	return hmm.HMM(name=name, states=all_states, null=copy.deepcopy(null_state))

#############
## Globals ##
#############

null_state = hmm.null_state_factory(arg.fasta, arg.null_ctx)
geneset = []

####################################
## Build gene-centric chromosomes ##
####################################

gene_count = 0
gen = Genome(gff3=arg.gff3, fasta=arg.fasta)
for chr in gen.chromosomes:
	for gene in chr.features:
		if not gene.mRNAs(): continue # some tx are miRNA etc
		tx = gene.mRNAs()[0]
		if tx.issues: continue
		rbeg = tx.beg - arg.padding
		rend = tx.end + arg.padding
		if rbeg < 1 or rend > len(chr.seq): continue
		dna = chromify(tx, rbeg, rend)
		geneset.append(dna)

######################################
## Build model-specific chromosomes ##
######################################

for dna in geneset:
	gene = dna.features[0]
	mRNA = gene.mRNAs()[0]
	
	if arg.model == 'internal_exon':
		splices = 0
		exon_len = 0
		int_len = 0
		for i in range(1, len(tx.exons) -1):
			iprev = tx.introns[i-1].seq_str()
			acc_seq = iprev[-arg.acc_len:len(iprev)]
			exon_seq = tx.exons[i].seq_str()
			don_seq = inext[0:arg.don_len]
			inext = tx.introns[i].seq_str()
			seq = iprev + acc_seq + exon_seq + don_seq + inext
			chr = DNA(seq=seq, name=dna.name + str(i))
			region = Feature(chr, 1, len(seq), '+', 'region')
			chr.feature.append(region)
			
			splices += 1
			exon_len += len(exon_seq)
			int_len += len(iprev)
"""
	
	# exon
	for exon in mRNA.exons:
		exn_seqs.append(exon.seq_str())
		exn_len += exon.length
		
	# intron & splice sites
	for intron in mRNA.introns:
		seq = intron.seq_str()
		don_seqs.append(seq[0:arg.don_len])
		int_seqs.append(seq[arg.don_len:-arg.acc_len])
		acc_seqs.append(seq[-arg.acc_len:len(seq)])
		int_len += len(seq) - arg.don_len - arg.acc_len
		splices += 1

	# mRNA-based sequences
	mRNAs += 1
	cds = tx.cds_str()
	ptx = tx.tx_str()
	beg = ptx.find(cds)
	end = beg + len(cds)
		
	atg_seq = cds[0:3]
	cds_seq = cds[3:]
	stp_seq = cds[-3:]
		
	atg_seqs.append(atg_seq)
	cds_seqs.append(cds_seq)
	stp_seqs.append(stp_seq)
	cds_len += len(cds_seq)
		
	# 5' end stuff
	if beg > arg.u5_ctx + arg.koz_len:
		ut5_seq = ptx[0 : beg - arg.koz_len]
		koz_seq = ptx[beg-arg.koz_len:beg]
		ut5_seqs.append(ut5_seq)
		koz_seqs.append(koz_seq)
		ut5_len += len(ut5_seq)
		
	# 3' end stuff (maybe include poly-A at some point)
	if len(ptx) - end > arg.u3_ctx:
		ut3_seq = ptx[end:]
		ut3_seqs.append(ut3_seq)
		ut3_len += len(ut

"""
"""
if arg.source:
	for n in range(arg.xvalid):
		setname = ''
		if (arg.xvalid != 1): setname = '-set' + str(n)
		with open(arg.source + setname + '.fasta', 'w+') as file:
			for dna in dataset[n]: file.write(dna.fasta())
		with open(arg.source + setname + '.gff3', 'w+') as file:
			for dna in dataset[n]: file.write(dna.features[0].gff())
	
	acc_seqs = [] # splice acceptors
	don_seqs = [] # splice donors
	exn_seqs = [] # exons, the whole thing
	int_seqs = [] # introns, minus the acceptor and donors
	cds_seqs = [] # coding sequence
	koz_seqs = [] # kozak-ish sequence (upstream of atg)
	ut5_seqs = [] # 5'UTR
	ut3_seqs = [] # 3'UTR
	atg_seqs = [] # translation start, which may not always be atg
	stp_seqs = [] # translation end, usually TAA|TAG|TGA
	
	exn_len = 0
	int_len = 0
	cds_len = 0
	ut5_len = 0
	ut3_len = 0
	splices = 0
	mRNAs = 0
	
	for dna in training:
		gene = dna.features[0]
		mRNA = gene.mRNAs()[0]
		
		# exon
		for exon in mRNA.exons:
			exn_seqs.append(exon.seq_str())
			exn_len += exon.length
		
		# intron & splice sites
		for intron in mRNA.introns:
			seq = intron.seq_str()
			don_seqs.append(seq[0:arg.don_len])
			int_seqs.append(seq[arg.don_len:-arg.acc_len])
			acc_seqs.append(seq[-arg.acc_len:len(seq)])
			int_len += len(seq) - arg.don_len - arg.acc_len
			splices += 1

		# mRNA-based sequences
		mRNAs += 1
		cds = tx.cds_str()
		ptx = tx.tx_str()
		beg = ptx.find(cds)
		end = beg + len(cds)
		
		atg_seq = cds[0:3]
		cds_seq = cds[3:]
		stp_seq = cds[-3:]
		
		atg_seqs.append(atg_seq)
		cds_seqs.append(cds_seq)
		stp_seqs.append(stp_seq)
		cds_len += len(cds_seq)
		
		# 5' end stuff
		if beg > arg.u5_ctx + arg.koz_len:
			ut5_seq = ptx[0 : beg - arg.koz_len]
			koz_seq = ptx[beg-arg.koz_len:beg]
			ut5_seqs.append(ut5_seq)
			koz_seqs.append(koz_seq)
			ut5_len += len(ut5_seq)
		
		# 3' end stuff (maybe include poly-A at some point)
		if len(ptx) - end > arg.u3_ctx:
			ut3_seq = ptx[end:]
			ut3_seqs.append(ut3_seq)
			ut3_len += len(ut3_seq)
	
	model = None
	if arg.model == 'internal_exon':
		ii = 1 - 1 / (int_len / len(int_seqs))
		ee = 1 - 1 /(exn_len / len(exn_seqs))
		model = make_model(
			arg.model, [                           # i  t  self
			['int',  'INTa', int_seqs, arg.int_ctx,  1, 0, ii],
			['acc',  'ACC',  acc_seqs, arg.acc_ctx,  0, 0, 0],
			['exon', 'EXON', exn_seqs, arg.exon_ctx, 0, 0, ee],
			['don',  'DON',  don_seqs, arg.don_ctx,  0, 0, 0],
			['int',  'INTb', int_seqs, arg.int_ctx,  0, 1, 1]])
	elif arg.model == 'splicing':
		pass
	elif arg.model == 'mRNA':
		pass
	else:
		raise ForgeError('unknown model type: ' + arg.model)
	
	model.convert2log() # note from here down, the model is log-space
	perf = decode.Performance(model)
	for dna in testing:
		v = decode.Viterbi(model=model, dna=dna)
		p = v.generate_path()
		features = p.features()
		perf.compare(source=dna.features, prediction=features)
	perf.report()
"""
